<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Certisure Demo ‚Äî Client Encryption + IPFS + PostgreSQL</title>
  <style>
    body{
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 950px;
      margin: 30px auto;
      padding: 18px;
      background:#f5f6f8;
    }
    .container{
      background:white;
      padding:24px;
      border-radius:10px;
      box-shadow:0 2px 10px rgba(0,0,0,0.1);
    }
    h1{ margin:0 0 10px; }
    .section{
      margin:18px 0;
      padding:14px 16px;
      border-left: 5px solid #4CAF50;
      border-radius:8px;
      background:#fafafa;
    }
    input, select, button{
      width:100%;
      padding:10px;
      margin-top:8px;
      border:1px solid #ddd;
      border-radius:6px;
      box-sizing:border-box;
    }
    button{
      background:#4CAF50;
      color:#fff;
      border:none;
      cursor:pointer;
      font-weight:600;
      font-size:15px;
    }
    button:hover{ background:#45a049; }
    button:disabled{ background:#bbb; cursor:not-allowed; }

    .output{
      background:#121212;
      color:#e4e4e4;
      padding:12px;
      border-radius:6px;
      margin-top:12px;
      font-family: Consolas, monospace;
      font-size:12px;
      white-space:pre-wrap;
      overflow:auto;
      max-height:280px;
    }
    .ok{ color:#33d17a; font-weight:700; }
    .bad{ color:#ff6b6b; font-weight:700; }
    .info{ color:#70a1ff; font-weight:700; }
    small{ color:#666; }
    a{ color:#70a1ff; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîê Certisure Demo</h1>
    <p><b>Client-side Encryption ‚Üí Backend ‚Üí IPFS CID ‚Üí PostgreSQL + MFS</b></p>
    <small>Backend URL: <span id="backendUrlText"></span></small>

    <!-- STEP 0 -->
    <div class="section">
      <h2>Step 0: IPFS Health Check</h2>
      <button onclick="checkIpfsHealth()">Check IPFS Health</button>
      <div id="ipfsOut" class="output"></div>
    </div>

    <!-- STEP 1 -->
    <div class="section">
      <h2>Step 1: Auth (Register / Login)</h2>
      <label>Email</label>
      <input id="email" type="email" value="srushti_demo@gmail.com" />
      
      <label>Password</label>
      <input id="password" type="password" value="1234" />

      <label>Role</label>
      <select id="role">
        <option value="OWNER">OWNER</option>
        <option value="NOMINEE">NOMINEE</option>
        <option value="ACCESS_NOMINEE">ACCESS_NOMINEE</option>
        <option value="VERIFIER">VERIFIER</option>
        <option value="ISSUER">ISSUER</option>
        <option value="REVIEWER">REVIEWER</option>
      </select>

      <button onclick="registerUser()">Register</button>
      <button onclick="loginUser()">Login</button>

      <div id="authOut" class="output"></div>
    </div>

    <!-- STEP 2 -->
    <div class="section">
      <h2>Step 2: Client-side Encryption</h2>
      <label>Select a file</label>
      <input type="file" id="fileInput" />

      <button onclick="encryptSelectedFile()">Encrypt File (Browser)</button>
      <div id="encOut" class="output"></div>
    </div>

    <!-- STEP 3 -->
    <div class="section">
      <h2>Step 3: Upload Encrypted File</h2>
      <label>Asset title</label>
      <input id="assetTitle" type="text" value="Encrypted Asset Demo" />

      <button id="uploadBtn" onclick="uploadEncrypted()" disabled>
        Upload to Backend (IPFS + DB)
      </button>

      <div id="uploadOut" class="output"></div>
    </div>

  </div>

<script>
  // ‚úÖ UPDATE BACKEND URL if needed
  const BACKEND_URL = "http://localhost:4000/api";
  document.getElementById("backendUrlText").textContent = BACKEND_URL;

  let token = null;
  let loggedInUser = null; 
  let encryptedState = null; 

  // ----------- Helper functions -----------
  function log(elId, msg) {
    document.getElementById(elId).textContent = msg;
  }
  function logHtml(elId, html) {
    document.getElementById(elId).innerHTML = html;
  }

  // Extract user_id from JWT token
  function getUserIdFromToken(jwtToken) {
    try {
      const payloadBase64 = jwtToken.split('.')[1];
      let base64 = payloadBase64.replace(/-/g, '+').replace(/_/g, '/');
      while (base64.length % 4) base64 += '=';
      const payloadJson = atob(base64);
      const payload = JSON.parse(payloadJson);
      return payload.user_id;
    } catch (e) {
      console.error('Failed to decode JWT:', e);
      return null;
    }
  }

  // Base64 helpers
  function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  // Crypto functions (AES-GCM)
  async function generateAesKey() {
    const key = await crypto.subtle.generateKey(
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
    const jwk = await crypto.subtle.exportKey("jwk", key);
    return { key, jwk };
  }

  async function sha256(bytes) {
    const input = bytes instanceof ArrayBuffer ? bytes : new Uint8Array(bytes).buffer;
    const digest = await crypto.subtle.digest("SHA-256", input);
    return arrayBufferToBase64(digest);
  }

  async function encryptFile(file) {
    const plain = await file.arrayBuffer();
    const { key, jwk } = await generateAesKey();
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const ciphertext = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      plain
    );

    const contentHash = await sha256(ciphertext);

    return {
      ciphertext,
      iv,
      keyJwk: jwk,
      ciphertextBase64: arrayBufferToBase64(ciphertext),
      ivBase64: arrayBufferToBase64(iv.buffer),
      contentHash,
      fileName: file.name,
      mimeType: file.type || "application/octet-stream",
      sizePlain: file.size,
      sizeEncrypted: ciphertext.byteLength,
    };
  }

  // ----------- Step 0: IPFS Health -----------
  window.checkIpfsHealth = async function () {
    log("ipfsOut", "Checking IPFS...");
    try {
      const res = await fetch(`${BACKEND_URL}/ipfs/health`);
      
      if (!res.ok) {
        throw new Error(`Backend returned ${res.status}: ${res.statusText}`);
      }
      
      const data = await res.json();

      if (data.connected) {
        logHtml("ipfsOut",
          `<span class="ok">‚úì IPFS connected</span>\n\n` +
          `API URL: ${data.apiUrl}\n` +
          `Version: ${data.version?.Version || "N/A"}\n\n` +
          `${JSON.stringify(data, null, 2)}`
        );
      } else {
        logHtml("ipfsOut",
          `<span class="bad">‚úó IPFS not connected</span>\n\n` +
          `API URL: ${data.apiUrl}\n` +
          `Error: ${data.error || "Unknown error"}\n\n` +
          `${JSON.stringify(data, null, 2)}`
        );
      }
    } catch (e) {
      logHtml("ipfsOut", `<span class="bad">Error:</span> ${e.message}`);
    }
  };

  // ----------- Step 1: Auth -----------
  window.registerUser = async function () {
    log("authOut", "Registering...");
    try {
      const email = document.getElementById("email").value.trim();
      const password = document.getElementById("password").value.trim();
      const role = document.getElementById("role").value;

      const res = await fetch(`${BACKEND_URL}/auth/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          full_name: "Demo User",
          email,
          password,
          role
        })
      });

      const data = await res.json();
      if (!res.ok) {
        logHtml("authOut", `<span class="bad">Register failed</span>\n\n${JSON.stringify(data, null, 2)}`);
        return;
      }

      token = data.token;
      loggedInUser = data.user;

      logHtml("authOut",
        `<span class="ok">‚úì Registered</span>\n\n` +
        `Token: ${token.substring(0,50)}...\n\n` +
        `${JSON.stringify(data, null, 2)}`
      );

    } catch (e) {
      logHtml("authOut", `<span class="bad">Error:</span> ${e.message}`);
    }
  };

  window.loginUser = async function () {
    log("authOut", "Logging in...");
    try {
      const email = document.getElementById("email").value.trim();
      const password = document.getElementById("password").value.trim();

      const res = await fetch(`${BACKEND_URL}/auth/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password })
      });

      const data = await res.json();
      if (!res.ok) {
        logHtml("authOut", `<span class="bad">Login failed</span>\n\n${JSON.stringify(data, null, 2)}`);
        return;
      }

      token = data.token;
      loggedInUser = data.user;

      logHtml("authOut",
        `<span class="ok">‚úì Logged in</span>\n\n` +
        `Token: ${token.substring(0,50)}...\n\n` +
        `${JSON.stringify(data.user, null, 2)}`
      );

    } catch (e) {
      logHtml("authOut", `<span class="bad">Error:</span> ${e.message}`);
    }
  };

  // ----------- Step 2: Encrypt -----------
  window.encryptSelectedFile = async function () {
    const fileInput = document.getElementById("fileInput");
    if (!fileInput.files[0]) {
      logHtml("encOut", `<span class="bad">Select a file first</span>`);
      return;
    }

    log("encOut", "Encrypting in browser...");
    try {
      const file = fileInput.files[0];
      const result = await encryptFile(file);

      encryptedState = {
        ciphertextBase64: result.ciphertextBase64,
        ivBase64: result.ivBase64,
        keyJwk: result.keyJwk,
        contentHash: result.contentHash,
        fileName: result.fileName,
        mimeType: result.mimeType,
      };

      document.getElementById("uploadBtn").disabled = false;

      logHtml("encOut",
        `<span class="ok">‚úì Encryption complete</span>\n\n` +
        `File: ${result.fileName}\n` +
        `Plain size: ${(result.sizePlain/1024).toFixed(2)} KB\n` +
        `Encrypted size: ${(result.sizeEncrypted/1024).toFixed(2)} KB\n` +
        `Ciphertext Hash (SHA-256): ${result.contentHash}\n` +
        `IV (base64): ${result.ivBase64.substring(0,30)}...\n\n` +
        `<span class="info">Plaintext never left browser ‚úÖ</span>`
      );

    } catch(e) {
      logHtml("encOut", `<span class="bad">Encryption error:</span> ${e.message}`);
    }
  };

  // ----------- Step 3: Upload -----------
  window.uploadEncrypted = async function () {
    if (!token) {
      alert("Please login/register first!");
      return;
    }
    if (!encryptedState) {
      alert("Please encrypt a file first!");
      return;
    }

    log("uploadOut", "Uploading ciphertext to backend...");
    try {
      const ciphertextBytes = Uint8Array.from(
        atob(encryptedState.ciphertextBase64),
        c => c.charCodeAt(0)
      );

      const blob = new Blob([ciphertextBytes], { type: "application/octet-stream" });

      const formData = new FormData();
      formData.append("file", blob, encryptedState.fileName);
      formData.append("title", document.getElementById("assetTitle").value || encryptedState.fileName);
      formData.append("type", encryptedState.mimeType);
      formData.append("content_hash", encryptedState.contentHash);

      const ownerId = getUserIdFromToken(token) || loggedInUser?.user_id;
      if (!ownerId) throw new Error("Could not extract user_id from token or user object");

      formData.append("owner_id", ownerId);

      const res = await fetch(`${BACKEND_URL}/assets`, {
        method: "POST",
        headers: { Authorization: `Bearer ${token}` },
        body: formData
      });

      const data = await res.json();
      if (!res.ok) {
        logHtml("uploadOut", `<span class="bad">Upload failed</span>\n\n${JSON.stringify(data, null, 2)}`);
        return;
      }

      const cid = data.asset?.encrypted_cid;

      logHtml("uploadOut",
        `<span class="ok">‚úì Upload successful</span>\n\n` +
        `Asset ID: ${data.asset.asset_id}\n` +
        `CID: ${cid}\n\n` +
        `Gateway URL:\n` +
        `<a href="http://127.0.0.1:8080/ipfs/${cid}" target="_blank">Open IPFS file</a>\n\n` +
        `${JSON.stringify(data.asset, null, 2)}`
      );

    } catch(e) {
      logHtml("uploadOut", `<span class="bad">Upload error:</span> ${e.message}`);
    }
  };
</script>
</body>
</html>
